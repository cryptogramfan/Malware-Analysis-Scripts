#!/usr/bin/env python
#
# A script that reads a list of strings and generates link charts that clusters similar strings
# together. Three distance metrics are supported to calculate string similarity: Jaccard, Hamming
# and Levenshtein. The script can be used as a technique for visualising phishing campaigns, for
# example by identifying similiar filenames and email subject lines. To use the script, supply a
# text file containing a list of strings. By default, the script outputs DOT files that can be 
# exported as images using Graphviz. If Graphviz is in your PATH you can also export to PNG or SVG.
#
# $ graph_similar_strings.py -f input.txt -m A -r filenames -o svg
# 
# Author.....: Alex Holland (@cryptogramfan)
# Date.......: 2019-11-18
# Version....: 0.0.2
# License....: CC BY 4.0

import sys
import argparse
import time
import re
import subprocess
import distance
import networkx as nx
import pandas as pd
import numpy as np
from networkx.algorithms import bipartite
from networkx.drawing.nx_agraph import write_dot

jaccard_threshold            = 0.2 # Similarity threshold where 0 means identical and 1 means totally different (default = 0.2).
hamming_threshold            = 5 # Similarity threshold where 1 means 1 character difference (default = 5).
levenshtein_threshold        = 7 # Similarity threshold where 1 means 1 character operation difference (default = 7).
levenshtein_length_threshold = 5 # The Levenshtein distance can be calculated between strings of different lengths. Only strings whose length difference is less than the threshold will be computed (default = 5). Reduce the threshold if the script is taking a long time to finish.

parser = argparse.ArgumentParser(description='\nUsage: graph_similar_strings.py -f <text_file> -a [JHLA]')
parser.add_argument('-f', '--file', dest='input_file', help='Text file containing strings', required=True)
parser.add_argument('-m', '--metric', choices=['jaccard', 'J', 'hamming', 'H', 'levenshtein', 'L', 'all', 'A'], help='Metric to calculate similarity', required=True)
parser.add_argument('-r', '--regex', choices=['filenames', 'f'], help='Filter strings first using regular expression')
parser.add_argument('-o', '--output', choices=['png', 'svg'], help='Output image format (requires Graphviz to be in your PATH)')
parsed_args = parser.parse_args()
network = nx.Graph()
timestr = time.strftime('%Y%m%d-%H%M%S')
jaccard_file = 'string_similarity_jaccard_' + timestr
hamming_file = 'string_similarity_hamming_' + timestr
levenshtein_file = 'string_similarity_levenshtein_' + timestr
regex_filenames = r'[^\\\/:*?"<>|\r\n]+$' # Regular expression to filter filenames for comparison

def parse_text():
	with open(parsed_args.input_file, 'r') as text_file:

		strings = [line.strip() for line in text_file]
		strings = filter(None, strings)
		print('[+] Processing ' + str(len(strings)) + ' strings...')
		
		if (parsed_args.regex == 'filenames') or (parsed_args.regex == 'f'):
			matched_strings = []
			
			for string in strings:
				matched_string = re.search(regex_filenames, string)
				
				if matched_string is None:
					pass

				else:
					matched_string = matched_string.group()
					matched_strings.append(matched_string)
			
			print('[+] Matched ' + str(len(matched_strings)) + ' filenames.')
			strings_a = matched_strings
			strings_b = matched_strings
		
		else:
			strings = filter(None, strings)
			strings_a = strings
			strings_b = strings

		return strings_a,strings_b

def calculate_jaccard(strings_a,strings_b):
	print('[+] Calculating Jaccard distance...')
	
	for string_a in strings_a:
		string_a = str(string_a)
		string_a = string_a.decode('utf-8').encode('ascii', 'xmlcharrefreplace')

		for string_b in strings_b:
			string_b = str(string_b)
			string_b = string_b.decode('utf-8').encode('ascii', 'xmlcharrefreplace')

			jaccard_distance = distance.jaccard(string_a, string_b)
			
			if 0 < jaccard_distance < jaccard_threshold:
				network.add_node(string_a,
						label=string_a.decode('utf-8').encode('ascii', 'xmlcharrefreplace')[:32],
						color='orange',
						style='filled',
						fillcolor='white',
						font_color='black',
						fontname='Arial',
						penwidth=5,
						bipartite=0)

				network.add_node(string_b,
						label=string_b.decode('utf-8').encode('ascii', 'xmlcharrefreplace')[:32],
						style='filled',
						fillcolor='white',
						color='orange',
						font_color='black',
						fontname='Arial',
						penwidth=5,
						bipartite=1)

				network.add_edge(string_b,
						string_a,
						penwidth=2,
						color='#0096D6',
						dir='none')

	try:	
		write_dot(network, jaccard_file + '.dot')
		print('[+] Created ' + jaccard_file + '.dot.')
	
	except:
		print('[!] Error creating DOT file.')
	
	if parsed_args.output == 'png':
		try:		
			subprocess.Popen(['sfdp',
							jaccard_file + '.dot',
							'-Tpng', 
							'-o', 
							jaccard_file + '.png',
							'-Goverlap=False',
							'-Goutputorder="edgesfirst"'])
							
			print('[+] Exported image as ' + jaccard_file + '.png.')
		
		except: 
			print('[!] Error saving image. Check that Graphviz is added to PATH.')
			exit(0)
			
	if parsed_args.output == 'svg':
		try:
			
			subprocess.Popen(['sfdp', 
							jaccard_file + '.dot',
							'-Goverlap=False',
							'-Tsvg', 
							'-o', 
							jaccard_file + '.svg',
							'-Goverlap=False',
							'-Goutputorder="edgesfirst"'])
							
			print('[+] Exported image as ' + jaccard_file + '.svg.')
			
		except: 
			print('[!] Error saving image. Check that Graphviz is added to PATH.')
		
	return

def calculate_hamming(strings_a,strings_b):
	print('[+] Calculating Hamming distance...')
	
	for string_a in strings_a:
		string_a = str(string_a)
		string_a = string_a.decode('utf-8').encode('ascii', 'xmlcharrefreplace')

		for string_b in strings_b:
			string_b = str(string_b)
			string_b = string_b.decode('utf-8').encode('ascii', 'xmlcharrefreplace')
			
			if len(string_a) == len(string_b): # Hamming distance can only be calculated for equal length strings
				hamming_distance = distance.hamming(string_a, string_b)

				if 0 < hamming_distance < hamming_threshold:
					network.add_node(string_a,
						label=string_a.decode('utf-8').encode('ascii', 'xmlcharrefreplace')[:32],
						color='orange',
						style='filled',
						fillcolor='white',
						font_color='black',
						fontname='Arial',
						penwidth=5,
						bipartite=0)

					network.add_node(string_b,
						label=string_b.decode('utf-8').encode('ascii', 'xmlcharrefreplace')[:32],
						style='filled',
						fillcolor='white',
						color='orange',
						font_color='black',
						fontname='Arial',
						penwidth=5,
						bipartite=1)

					network.add_edge(string_b,
						string_a,
						penwidth=2,
						color='#0096D6',
						dir='none')
	
	try:
		write_dot(network, hamming_file + '.dot')
		print('[+] Created ' + hamming_file + '.dot.')
		
	except:
		print('[!] Error creating DOT file.')
		
	if parsed_args.output == 'png':
		try:
			subprocess.Popen(['sfdp',
							hamming_file + '.dot',
							'-Tpng', 
							'-o', 
							hamming_file + '.png',
							'-Goverlap=False',
							'-Goutputorder="edgesfirst"'])
							
			print('[+] Exported image as ' + hamming_file + '.png.')
		
		except: 
			print('[!] Error saving image. Check that Graphviz is added to PATH.')
			
	if parsed_args.output == 'svg':
		try:
			subprocess.Popen(['sfdp', 
							hamming_file + '.dot',
							'-Tsvg', 
							'-o', 
							hamming_file + '.svg',
							'-Goverlap=False',
							'-Goutputorder="edgesfirst"'])
							
			print('[+] Exported image as ' + hamming_file + '.svg.')
		
		except: 
			print('[!] Error saving image. Check that Graphviz is added to PATH.')
			
	return

def calculate_levenshtein(strings_a,strings_b):
	print('[+] Calculating Levenshtein distance...')
	
	for string_a in strings_a:
		string_a = str(string_a)
		string_a = string_a.decode('utf-8').encode('ascii', 'xmlcharrefreplace')

		for string_b in strings_b:
			string_b = str(string_b)
			string_b = string_b.decode('utf-8').encode('ascii', 'xmlcharrefreplace')

			if -levenshtein_length_threshold < (len(string_a) - len(string_b)) < levenshtein_length_threshold:
				levenshtein_distance = distance.levenshtein(string_a, string_b)

				if 0 < levenshtein_distance < levenshtein_threshold:
					network.add_node(string_a,
						label=string_a.decode('utf-8').encode('ascii', 'xmlcharrefreplace')[:32],
						color='orange',
						style='filled',
						fillcolor='white',
						font_color='black',
						fontname='Arial',
						penwidth=5,
						bipartite=0)

					network.add_node(string_b,
						label=string_b.decode('utf-8').encode('ascii', 'xmlcharrefreplace')[:32],
						style='filled',
						fillcolor='white',
						color='orange',
						font_color='black',
						fontname='Arial',
						penwidth=5,
						bipartite=1)

					network.add_edge(string_b,
						string_a,
						penwidth=2,
						color='#0096D6',
						dir='none')
	try:
		write_dot(network, levenshtein_file + '.dot')
		print('[+] Created ' + levenshtein_file + '.dot.')
		
	except:
		print('[!] Error creating DOT file.')
		
	if parsed_args.output == 'png':
		try:
			subprocess.Popen(['sfdp',
							levenshtein_file + '.dot', 
							'-Tpng', 
							'-o', 
							levenshtein_file + '.png',
							'-Goverlap=False',
							'-Goutputorder="edgesfirst"'])
							
			print('[+] Exported image as ' + levenshtein_file + '.png.')
		
		except: 
			print('[!] Error saving image. Check that Graphviz is added to PATH.')
			
	if parsed_args.output == 'svg':
		try:
			subprocess.Popen(['sfdp', 
							levenshtein_file + '.dot',
							'-Tsvg', 
							'-o', 
							levenshtein_file + '.svg',
							'-Goverlap=False',
							'-Goutputorder="edgesfirst"'])
							
			print('[+] Exported image as ' + levenshtein_file + '.svg.')
		
		except: 
			print('[!] Error saving image. Check that Graphviz is added to PATH.')
		
	return

strings_a,strings_b = parse_text()

if (parsed_args.metric == 'jaccard') or (parsed_args.metric == 'J'):
	calculate_jaccard(strings_a,strings_b)

if (parsed_args.metric == 'hamming') or (parsed_args.metric == 'H'):
	calculate_hamming(strings_a,strings_b)

if (parsed_args.metric == 'levenshtein') or (parsed_args.metric == 'L'):
	calculate_levenshtein(strings_a,strings_b)

if (parsed_args.metric == 'all') or (parsed_args.metric == 'A'):
	calculate_jaccard(strings_a,strings_b)
	calculate_hamming(strings_a,strings_b)
	calculate_levenshtein(strings_a,strings_b)

exit(0)